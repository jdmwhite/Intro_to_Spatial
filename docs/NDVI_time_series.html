<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>NDVI time series</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Intro to Spatial Data in R</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="Making_a_map.html">Making a map</a>
</li>
<li>
  <a href="NDVI_time_series.html">NDVI time series</a>
</li>
<li>
  <a href="Resources.html">Additional Resources</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">NDVI time series</h1>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<div id="learning-objectives" class="section level3">
<h3>Learning objectives</h3>
<ol style="list-style-type: decimal">
<li>Download MODIS vegetation indices</li>
<li>Process raster data</li>
<li>Produce a summarised time series</li>
</ol>
</div>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>In this tutorial, we will delve into satellite data to better
understand patterns of landscape change over space and time. So far, we
have explored spatial functions, but dealing with time and dates adds
another level of complexity to our analysis. To manage this, we will use
several <code>mapping</code> or <code>looping</code> functions. These
functions iterate a function over every element in our list or
collection. This is important to learn for many elements of programming
(such as in <a href="https://earthengine.google.com/">Google Earth
Engine</a>), but becomes extremely useful in collections of satellite
data over time.</p>
<div class="figure" style="text-align: center">
<img src="images/raster_by_time_edzer_UseR2019.png" alt="A collection of rasters over time. Source: Edzer Pebesma UseR! 2019 Spatial workshop" width="60%" />
<p class="caption">
A collection of rasters over time. Source: Edzer Pebesma UseR! 2019
Spatial workshop
</p>
</div>
<p>Satellite data can take many forms, but today we will be using
passive, optical data collected from the <a
href="https://viirsland.gsfc.nasa.gov/Val/VI_Val.html">NASA VIIRS
satellite</a>. This satellite works by capturing electromagnetic
information reflected from the surface of the earth using sensors.
Depending on the sensitivity of the satellite (i.e. the spectral
resolution), this information may be captured along different spectral
<strong>bands</strong>. Some of these we are familiar with, such as the
Red, Green or Blue band. When combining these bands together, they form
a ‘true’ colour image. They also collect spectral information along
longer wavelengths, in the infrared range. A band of particular
importance to understanding vegetation dynamics is the near-infrared
band.</p>
<div class="figure" style="text-align: center">
<img src="images/em_spectrum.png" alt="The electromagnetic spectrum, highlighting typical bands used in satellite remote sensing." width="60%" />
<p class="caption">
The electromagnetic spectrum, highlighting typical bands used in
satellite remote sensing.
</p>
</div>
</div>
<div id="ndvi" class="section level3">
<h3>NDVI</h3>
<p>There are certain properties of plants that make these bands useful
to us. For example, healthy vegetation reflects more near-infrared (NIR)
and green light, but absorbs more red and blue light. This is largely
why healthy vegetation looks green to our eyes. Vegetation that is
stressed or unhealthy will typically absorb more NIR and reflect more
red light, in turn producing different colours, which our eyes may
interpret as yellow or brown.</p>
<div class="figure" style="text-align: center">
<img src="images/ndvi_example.jpg" alt="The relationship between NIR and red bands for healthy (left) and unhealthy (right) vegetation. Source: NASA" width="60%" />
<p class="caption">
The relationship between NIR and red bands for healthy (left) and
unhealthy (right) vegetation. Source: NASA
</p>
</div>
<p>The Normalized Difference Vegetation Index uses the NIR and red bands
to formulate this relationship: <span class="math display">\[
NDVI = \frac{(NIR - red)}{(NIR + red)}
\]</span> NDVI can provide valuable information on phenology, vegetation
productivity, agriculture, or disturbancs such as deforestation, illegal
ploughing or wild fires.</p>
<div class="figure" style="text-align: center">
<img src="images/sa_modis.gif" alt="NDVI change over South Africa across a single year" width="60%" />
<p class="caption">
NDVI change over South Africa across a single year
</p>
</div>
<p>There are many other indices out there for vegetation, water, fire
scars and many more. For most satellites, we will need to calculate
these indices ourselves. Fortunately, there are also products, such as
the MODIS vegetation images, which provide these indices for us. We will
use these in our practical.</p>
</div>
<div id="tutorial" class="section level3">
<h3>Tutorial</h3>
<p>Let’s start coding. First install and load packages:</p>
<pre class="r"><code># install.packages(&#39;MODISTools&#39;)
# install.packages(&#39;tidyverse&#39;)
# install.packages(&#39;terra&#39;)
# install.packages(&#39;lubridate&#39;)

#### Load packages ----
library(MODISTools) # downloading modis data
library(tidyverse) # data manipulation and plotting
library(terra) # raster manipulation
library(lubridate) # dates</code></pre>
<div id="explore-the-data" class="section level4">
<h4>Explore the data</h4>
<p>Using the <code>MODISTools</code> package, we have direct access to
all of the Moderate Resolution Imaging Spectroradiometer (MODIS) and
other (e.g. VIIRS) satellite imagery. This satellite collects data on
the atmosphere, land and ocean. Read up more on the land mission <a
href="https://modis-land.gsfc.nasa.gov/">here</a>.</p>
<p>We will first load in our area of interest, which is the municipal
boundary for the City of Johannesburg.</p>
<pre class="r"><code>#### Load in our area of interest for later----
coj &lt;- vect(&quot;data/land_cover_change/COJ_boundary.shp&quot;)</code></pre>
<p>Then we will identify all of the products available through
<code>MODISTools</code>. We will then select the VIIRS product for
vegetation indices and explore the available bands. This product gives
both Normalized Difference Vegetation Index (NDVI) and Enhanced
Vegetation Index (EVI) every 16 days across the globe at a spatial scale
of 500m. Additionally, it provides RGB bands and information on the
pixel reliability, which we will both use.</p>
<p>There are products that produce a finer temporal and spatial
resolution, which may suit a study working within a smaller area, but we
will not require this here.</p>
<pre class="r"><code>#### Explore modis products ----
# All products available
products &lt;- mt_products()
head(products)</code></pre>
<pre><code>##        product
## 1       Daymet
## 2 ECO4ESIPTJPL
## 3      ECO4WUE
## 4       GEDI03
## 5     GEDI04_B
## 6      MCD12Q1
##                                                                       description
## 1 Daily Surface Weather Data (Daymet) on a 1-km Grid for North America, Version 4
## 2            ECOSTRESS Evaporative Stress Index PT-JPL (ESI) Daily L4 Global 70 m
## 3                       ECOSTRESS Water Use Efficiency (WUE) Daily L4 Global 70 m
## 4             GEDI Gridded Land Surface Metrics (LSM) L3 1km EASE-Grid, Version 2
## 5    GEDI Gridded Aboveground Biomass Density (AGBD) L4B 1km EASE-Grid, Version 2
## 6           MODIS/Terra+Aqua Land Cover Type (LC) Yearly L3 Global 500 m SIN Grid
##   frequency resolution_meters
## 1     1 day              1000
## 2    Varies                70
## 3    Varies                70
## 4  One time              1000
## 5  One time              1000
## 6    1 year               500</code></pre>
<pre class="r"><code># bands of the vegetation indices product
bands &lt;- mt_bands(product = &quot;VNP13A1&quot;)
head(bands)</code></pre>
<pre><code>##                                      band
## 1          500_m_16_days_blue_reflectance
## 2 500_m_16_days_composite_day_of_the_year
## 3                       500_m_16_days_EVI
## 4                      500_m_16_days_EVI2
## 5         500_m_16_days_green_reflectance
## 6                      500_m_16_days_NDVI
##                              description                  units     valid_range
## 1  Blue band (M3 478-498 nm) reflectance            reflectance      0 to 10000
## 2                        Day of the year Julian day of the year        1 to 366
## 3                     16 day EVI average   EVI ratio - No units -10000 to 10000
## 4                    16 day EVI2 average  EVI2 ratio - No units -10000 to 10000
## 5 Green band (M4 545-565 nm) reflectance            reflectance      0 to 10000
## 6                    16 day NDVI average  NDVI ratio - No units -10000 to 10000
##   fill_value scale_factor add_offset
## 1      -1000       0.0001          0
## 2         -1         &lt;NA&gt;       &lt;NA&gt;
## 3     -15000       0.0001          0
## 4     -15000       0.0001          0
## 5      -1000       0.0001          0
## 6     -15000       0.0001          0</code></pre>
<p>We can then explore all of the available dates for a location of
interest - in this case a central point in Johannesburg.</p>
<pre class="r"><code># dates available for a specific coordinate
dates &lt;- mt_dates(product = &quot;VNP13A1&quot;, lat = -26.2041, lon = 28.0473)
head(dates)</code></pre>
<pre><code>##   modis_date calendar_date
## 1   A2012017    2012-01-17
## 2   A2012025    2012-01-25
## 3   A2012033    2012-02-02
## 4   A2012041    2012-02-10
## 5   A2012049    2012-02-18
## 6   A2012057    2012-02-26</code></pre>
</div>
<div id="downloading-modis-data" class="section level4">
<h4>Downloading MODIS data</h4>
<p>We will now set up the parameters for downloading the vegetation
index (VI) data. This requires the product of interest (VIIRS Vegetation
Index product), latitude and longitude (Johannesburg) and a start and
end date (all of 2021). We can also specify which bands we want, which
will make our download faster. Here we take the NDVI band and a pixel
reliability band.</p>
<p>We can also specify an area around the coordinate to download data
from. Here we specify 25km left and right (<code>km_lr</code>) and 40km
above and below (<code>km_ab</code>).</p>
<pre class="r"><code>#### Download NDVI data for JHB ----
start_time &lt;- Sys.time()
jhb_ndvi &lt;- mt_subset(product = &quot;VNP13A1&quot;,
                          lat = -26.183483,
                          lon =  27.975311,
                          band = c(&quot;500_m_16_days_NDVI&quot;,
                                   &quot;500_m_16_days_pixel_reliability&quot;),
                          start = &quot;2021-01-01&quot;,
                          end = &quot;2021-12-30&quot;,
                          km_lr = 25,
                          km_ab = 40,
                          site_name = &quot;JHB&quot;,
                          internal = TRUE,
                          progress = TRUE)</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |==============                                                        |  20%
  |                                                                            
  |============================                                          |  40%
  |                                                                            
  |==========================================                            |  60%
  |                                                                            
  |========================================================              |  80%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |==============                                                        |  20%
  |                                                                            
  |============================                                          |  40%
  |                                                                            
  |==========================================                            |  60%
  |                                                                            
  |========================================================              |  80%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre class="r"><code>end_time &lt;- Sys.time()
# How long does it take to download 200 km2 of VIIRS NDVI data at 500 m resolution for 2 bands?
end_time - start_time</code></pre>
<pre><code>## Time difference of 1.816065 mins</code></pre>
<p>Impressively, this only took 1.5 minutes to download 46 images overe
200 km2. An interesting feature of the <code>MODISTools</code> package,
is that it downloads data as a <code>data.frame</code>. This makes it
easy to manipulate and immediately visualise using data wrangling tools
in the <code>tidyverse</code>. It is still a big data frame (~1.5
million rows) - so let’s filter and summarise it down a bit.</p>
</div>
<div id="plot-time-series" class="section level4">
<h4>Plot time series</h4>
<p>Our aim is to produce a single median NDVI value for each unique date
and plot it. Importantly, we need to rescale the NDVI data using the
value in the <code>scale</code> column.</p>
<pre class="r"><code># Summarise
jhb_ndvi %&gt;% 
  filter(band == &quot;500_m_16_days_NDVI&quot;) %&gt;%
  group_by(calendar_date) %&gt;%
  summarise(doy = yday(as_date(calendar_date)),
            ndvi_median = median(value * as.numeric(scale))) %&gt;% 
  distinct(doy, .keep_all = TRUE) -&gt; jhb_med_ndvi</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;calendar_date&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre class="r"><code>head(jhb_med_ndvi)</code></pre>
<pre><code>## # A tibble: 6 × 3
## # Groups:   calendar_date [6]
##   calendar_date   doy ndvi_median
##   &lt;chr&gt;         &lt;dbl&gt;       &lt;dbl&gt;
## 1 2021-01-01        1       0.620
## 2 2021-01-09        9       0.563
## 3 2021-01-17       17       0.562
## 4 2021-01-25       25       0.329
## 5 2021-02-02       33       0.634
## 6 2021-02-10       41       0.550</code></pre>
<pre class="r"><code># Plot
ggplot(jhb_med_ndvi, aes(x = doy, y = ndvi_median)) +
  geom_point() +
  geom_smooth(method = &#39;loess&#39;) +
  labs(x = &#39;Day of Year&#39;, y = &#39;NDVI (median)&#39;) +
  theme_classic() </code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p><img src="NDVI_time_series_files/figure-html/summarise%20data-1.png" width="672" /></p>
<p>In very few lines of code - we already have a time series plot! Let’s
save it:</p>
<pre class="r"><code># Save plot
ggsave(&#39;output/figs/ndvi_time_series/jhb_med_ndvi.png&#39;,
       width = 120, height = 80, units = c(&#39;mm&#39;), dpi = &#39;retina&#39;, bg = &#39;white&#39;)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p>You may notice that in February there is a very odd, outlying
observation. Let’s convert the data frame to rasters to explore this a
bit further.</p>
</div>
<div id="convert-ndvi-data-frame-to-rasters" class="section level4">
<h4>Convert NDVI data frame to rasters</h4>
<pre class="r"><code># filter to NDVI and then split the data frame into a list by date
jhb_ndvi_split &lt;- jhb_ndvi %&gt;% filter(band == &quot;500_m_16_days_NDVI&quot;) %&gt;% split(jhb_ndvi$calendar_date)</code></pre>
<pre><code>## Warning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data
## length is not a multiple of split variable</code></pre>
<!-- #### Process MODIS data -->
<!-- We can now load the MODIS data into R and begin exploring the data locally and start with processing.  -->
<!-- ```{r} -->
<!-- #### Load in and process MODIS data -->
<!-- modis_files <- list.files('data/') -->
<!-- modis_files -->
<!-- # Let's use one raster image to explore the data -->
<!-- r1 <- rast(paste0('data/',modis_files[1])) -->
<!-- r1 -->
<!-- # Image properties -->
<!-- crs(r1) # CRS -->
<!-- res(r1) # resolution -->
<!-- nlyr(r1) # number of layers -->
<!-- names(r1) # names of layers -->
<!-- # We can also change the resolution, by aggregating cells. This is useful for later -->
<!-- r1_agg <- aggregate(r1, fact = 5, fun = 'mean') -->
<!-- res(r1_agg) -->
<!-- #### Plot an image -->
<!-- plot(r1[[1]]) -->
<!-- plot(r1_agg[[1]]) # plot the first layer -->
<!-- plot(r1_agg[[1]]/100000000) # plot with a scale factor -->
<!-- ``` -->
<!-- From **gisgeography**: "Normalized Difference Vegetation Index (NDVI) quantifies vegetation by measuring the difference between near-infrared (which vegetation strongly reflects) and red light (which vegetation absorbs)." -->
<!-- NDVI can only fall between -1 and 1. A simplified understanding of NDVI values may say: values greater than 0.6 may indicate healthy vegetation, values lower than 0.6 but greater than 0, may indicate unhealthy vegetation. Values below 0 are likely to be water. Read up more on NDVI at [**gisgeography**](https://gisgeography.com/ndvi-normalized-difference-vegetation-index/), where they explain the calculation and the use of different satellite bands.  -->
<!-- #### Processing MODIS data -->
<!-- We have multiple images for the same date over different regions as shown below. So we need to 'mosaic' these together. Many of the following 'for loops' are only required because we have several images. If you only have one image, many of these steps will not be required.  -->
<!-- ```{r} -->
<!-- r2 <- rast(paste0('data/',modis_files[2])) -->
<!-- par(mfrow=c(1,2)) -->
<!-- plot(r1[[1]]) -->
<!-- plot(r2[[1]]) -->
<!-- ``` -->
<!-- First, we will collect acquisition dates from file names. They are stored as yyyyddd, meaning the year and the julian day the image was collected. We want to extract the year and julian day, i.e. characters 10 to 13 and characters 14 to 16. -->
<!-- ```{r} -->
<!-- modis_files[1] -->
<!-- substr(modis_files[1], 14, 16) # for example, the first image was taken on the 353rd day of the year -->
<!-- substr(modis_files[1], 10, 13) # we also need to extract the year -->
<!-- my_dates_vector <- vector() -->
<!-- for(i in 1:length(modis_files)){ -->
<!--   jday <- substr(modis_files[i], 14, 16) -->
<!--   year <- substr(modis_files[i], 10, 13) -->
<!--   # need to convert this to a date -->
<!--   date <- ifelse(year < 2021,  -->
<!--        as.character(as.Date(as.numeric(jday), origin = '2020-01-01')), -->
<!--        as.character(as.Date(as.numeric(jday), origin = '2021-01-01'))) -->
<!--   my_dates_vector[i] <- date -->
<!-- } -->
<!-- my_dates_vector -->
<!-- ``` -->
<!-- Now that we have the dates, we can load all of the MODIS images into our local environment as a list. We will also change the spatial resolution of each image as we load it into the list: -->
<!-- ```{r} -->
<!-- #### Load in all rasters as a list and change resolution -->
<!-- my_raster_list <- list() -->
<!-- for(i in 1:length(modis_files)){ -->
<!--   r <- rast(paste0('data/',modis_files[i])) -->
<!--   names(r)[1] <- 'NDVI' -->
<!--   my_raster_list[[i]] <- aggregate(r, fact = 5, fun = 'mean') -->
<!-- } -->
<!-- length(my_raster_list) -->
<!-- ``` -->
<!-- We can now `mosaic` the rasters together. This function basically stitches the different rasters together. We run this over a grouping loop that uses the unique date of each image to identify which rasters belong together: -->
<!-- ```{r} -->
<!-- my_dates_vector_unique <- unique(my_dates_vector) -->
<!-- my_mosaic_list <- list() -->
<!-- for(i in 1:length(my_dates_vector_unique)){ -->
<!--   index <- which(my_dates_vector %in% my_dates_vector_unique[i]) -->
<!--     rlist_temp <- my_raster_list[index] -->
<!--     spat_rast_coll <- sprc(rlist_temp) -->
<!--     my_mosaic_list[[i]] <- mosaic(spat_rast_coll) -->
<!-- } -->
<!-- length(my_mosaic_list) -->
<!-- ``` -->
<!-- We now have 5 unique images, which we can plot out: -->
<!-- ```{r} -->
<!-- # Plot new mosaiced rasters -->
<!-- par(mfrow = c(3,2)) -->
<!-- plot(my_mosaic_list[[1]]$NDVI); title(my_dates_vector_unique[1]) -->
<!-- plot(my_mosaic_list[[2]]$NDVI); title(my_dates_vector_unique[2]) -->
<!-- plot(my_mosaic_list[[3]]$NDVI); title(my_dates_vector_unique[3]) -->
<!-- plot(my_mosaic_list[[4]]$NDVI); title(my_dates_vector_unique[4]) -->
<!-- plot(my_mosaic_list[[5]]$NDVI); title(my_dates_vector_unique[5]) -->
<!-- ``` -->
<!-- Next, we re-project the data to a format we're familiar with and that links to our *Protea* location data: -->
<!-- ```{r} -->
<!-- crs <- "+proj=longlat +datum=WGS84" -->
<!-- my_mosaic_list_reproj <- lapply(my_mosaic_list, function(x) project(x, crs)) -->
<!-- par(mfrow=c(1,1)) -->
<!-- plot(my_mosaic_list_reproj[[1]]$NDVI) -->
<!-- points(as_Spatial(p_roup)) -->
<!-- ``` -->
<!-- Lastly, we can discard the bands we do not need and only keep the NDVI band. At the same time, we will scale the NDVI values to fall between -1 and 1: -->
<!-- ```{r} -->
<!-- my_mosaic_list_scale <- lapply(my_mosaic_list_reproj, function(x) x$NDVI/100000000) -->
<!-- par(mfrow=c(2,1)) -->
<!-- plot(my_mosaic_list[[5]]$NDVI); points(as_Spatial(p_roup)) -->
<!-- plot(my_mosaic_list_scale[[1]]); points(as_Spatial(p_roup)) -->
<!-- ``` -->
<!-- #### Extract NDVI values for each *Protea* location -->
<!-- We now want to extract NDVI values for each *Protea* location across each time interval. To do this, we use `terra::extract`, which requires a raster and vector file. We run the `lapply` function, which is another type of `loop` function. It is designed to run over a list.  -->
<!-- Once the dataset is extract, we change the name of each column to each date and then 'pivot' or transform our dataframe to a long format. We can then easily calculate summary statistics, such as mean, standard deviation and standard error of NDVI across all *Proteas*. -->
<!-- ```{r} -->
<!-- pr_ndvi_list <- lapply(my_mosaic_list_scale, function(x) terra::extract(x, st_coordinates(p_roup))) -->
<!-- pr_ndvi_df <- data.frame(pr_ndvi_list) -->
<!-- names(pr_ndvi_df) <- my_dates_vector_unique -->
<!-- pr_ndvi_df$lon <- st_coordinates(p_roup)[,1] -->
<!-- pr_ndvi_df$lat <- st_coordinates(p_roup)[,2] -->
<!-- head(pr_ndvi_df) -->
<!-- # Pivot to long form dataframe -->
<!-- pr_ndvi_long <- pr_ndvi_df %>% pivot_longer(cols = 1:5, names_to = 'date', values_to = 'ndvi') -->
<!-- # Summarise NDVI values for each date across P.r. locations -->
<!-- ndvi_summary <- pr_ndvi_long %>% group_by(date) %>% summarise(mean = mean(ndvi), -->
<!--                                               sd = sd(ndvi), -->
<!--                                               se = sd(ndvi)/sqrt(n())) -->
<!-- ``` -->
<!-- We now plot a time series of NDVI values across all *Proteas*.  -->
<!-- ```{r} -->
<!-- ggplot(data = ndvi_summary) + -->
<!--   geom_line(aes(x = as.Date(date), y = mean)) -->
<!-- ``` -->
<!-- This plot looks odd! But recognise that the y-axis is very truncated. We can change the parameters, which show that there is a general increase or stable NDVI change over the ~2 months we are focusing on. -->
<!-- ```{r} -->
<!-- ggplot(data = ndvi_summary) + -->
<!--   geom_ribbon(aes(x = as.Date(date), y = mean, ymin = mean - sd, ymax = mean + sd), alpha = 0.3) + -->
<!--   geom_line(aes(x = as.Date(date), y = mean)) + -->
<!--   geom_point(aes(x = as.Date(date), y = mean)) + -->
<!--   scale_x_date(labels = scales::date_format("%d-%m-%Y"), limits = c(as.Date('2020-12-15'), as.Date('2021-02-20'))) + -->
<!--   scale_y_continuous(limits = c(0,1)) + -->
<!--   xlab('Date') + ylab('NDVI') + -->
<!--   theme_classic() -->
<!-- ``` -->
<!-- For comparison, we can also calculate the summary statistics and plot the time-series of NDVI values across full region (i.e. over each raster cell rather than each *Protea* location) for each unique date. -->
<!-- ```{r} -->
<!-- my_cellstats_list <- list() -->
<!-- for(i in 1:length(my_mosaic_list_scale)){ -->
<!-- mean <- global(my_mosaic_list_scale[[i]], 'mean', na.rm = TRUE) -->
<!-- sd <- global(my_mosaic_list_scale[[i]], 'sd', na.rm = TRUE) -->
<!-- se <- sd/sqrt(ncell(my_mosaic_list_scale[[i]])) -->
<!-- my_cellstats_list[[i]] <- data.frame(i,mean, sd, se) -->
<!-- } -->
<!-- cell_summary <- bind_rows(my_cellstats_list) -->
<!-- cell_summary$date <- my_dates_vector_unique -->
<!-- ``` -->
<!-- Now plot these values with the same plot specifications as the previous plot, so they are easily comparable.  -->
<!-- ```{r} -->
<!-- ggplot(data = cell_summary) + -->
<!--   geom_ribbon(aes(x = as.Date(date), y = mean, ymin = mean - sd, ymax = mean + sd), alpha = 0.3) + -->
<!--   geom_line(aes(x = as.Date(date), y = mean)) + -->
<!--   geom_point(aes(x = as.Date(date), y = mean)) + -->
<!--   scale_x_date(labels = scales::date_format("%d-%m-%Y"), limits = c(as.Date('2020-12-15'), as.Date('2021-02-20'))) + -->
<!--   scale_y_continuous(limits = c(0,1)) + -->
<!--   xlab('Date') + ylab('NDVI') + -->
<!--   theme_classic() -->
<!-- ``` -->
<!-- What is the difference in the NDVI trend between the *Proteas* and between the background values? -->
<!-- #### Animate NDVI map -->
<!-- For presentations, it is often valuable to animate time series data. We can do this using a few different approaches, but here we will use `gganimate`, which links nicely with the `ggplot2` package. -->
<!-- First, we need a little bit more processing of the raster layers. We select the countries we are interested in and then we use the `mask` function to remove all cells in our rasters that fall outside of these countries. Plot the output to see if this worked: -->
<!-- ```{r} -->
<!-- sern_a <- ne_countries(country = c('South Africa','Lesotho','Swaziland'), returnclass = 'sf', scale = 'medium') -->
<!-- st_crs(sern_a) -->
<!-- # mask the layer by sern African countries -->
<!-- my_rast_crop <- lapply(my_mosaic_list_scale, function(x) mask(x, vect(sern_a))) -->
<!-- par(mfrow=c(1,1)) -->
<!-- plot(my_rast_crop[[1]]); points(as_Spatial(p_roup)) -->
<!-- plot(as_Spatial(sern_a), add = TRUE) -->
<!-- ``` -->
<!-- As this practical has somewhat turned into a lesson on loops, here is another application using the `purrr` package. The function `map` in the `purrr` package applies a function to each element of the list. In this case, we want to use the `map_dfr` function, which returns a data frame and binds all successive elements onto the data frame.  -->
<!-- The function we want to apply to each element within the `my_rast_crop` list is `as.data.frame()`. This converts our raster into a data frame. We wrap this function in the `setNames()` function, so that we can specify our new column names as x, y and NDVI for our value column. Lastly, we add on a unique ID for each raster, which we label `Date`. We can then use the ID column to assign the correct date to each image in our long format data frame.  -->
<!-- ```{r} -->
<!-- # Convert the rasters to a long format dataframe and give each raster a unique ID -->
<!-- mydf <- purrr::map_dfr( -->
<!--   my_rast_crop,  -->
<!--   ~setNames(as.data.frame(., xy = TRUE), c('x', 'y','NDVI')),  -->
<!--   .id = 'Date' -->
<!-- ) -->
<!-- # Convert this ID to the date of the raster -->
<!-- mydf <- mydf %>% mutate(Date = as.Date(case_when( -->
<!--   Date == 1 ~ my_dates_vector_unique[1], -->
<!--   Date == 2 ~ my_dates_vector_unique[2], -->
<!--   Date == 3 ~ my_dates_vector_unique[3], -->
<!--   Date == 4 ~ my_dates_vector_unique[4], -->
<!--   Date == 5 ~ my_dates_vector_unique[5], -->
<!-- ))) -->
<!-- ``` -->
<!-- We are now ready to set up our animation. Create a base ggplot and plot the raster using `geom_tile`. Specify your x and y coordinates and use NDVI as the 'fill' option. For context, we add in our southern African countries and *Protea* locations as simple features using `geom_sf`. -->
<!-- ```{r} -->
<!-- # Create a base ggplot -->
<!-- gg_base <- ggplot() + -->
<!--   geom_tile(data = mydf, aes(x = x, y = y, fill = NDVI)) + -->
<!--   scale_fill_gradient2(low = '#c4b68c', mid = '#628c2c', high = '#000f0f', midpoint = 0.4, breaks = c(-0.25, 0, 0.25, 0.5, 0.75, 1), limits = c(-0.25, 1), name = 'NDVI') + -->
<!--   geom_sf(data = sern_a, fill = NA, col = 'black', lwd = 0.2) + -->
<!--   geom_sf(data = p_roup, pch = 1, cex = 0.2, col = 'white') + -->
<!--   scale_x_continuous(limits = c(22, 33)) + -->
<!--   scale_y_continuous(limits = c(-34.5, -22)) + -->
<!--   xlab('Longitude') + ylab('Latitude') + -->
<!--   coord_sf() + -->
<!--   theme_minimal() -->
<!-- ``` -->
<!-- To animate this plot, we add on the function `transition_states` from the `gganimate` package. This function requires the variable that we want to change (i.e. **Date**). We then specify how long we want the transition between frames to take, and how long the animation should stay on each frame (state_length). Using the `labs(title = '')` argument, we can also provide a title to each frame. Here we use `{closest_state}`, which means it will display the **Date** of the closest frame. -->
<!-- ```{r} -->
<!-- # Now add in the transitions -->
<!-- gg_base + transition_states(states = Date, transition_length = 0.01, state_length = 1) + labs(title = "Date: {closest_state}") -->
<!-- # Date is the variable we want to change per frame; transition_length is the time between each frame; state_length is the time that the animation stays on the frame -->
<!-- # The title label is then set to 'closest_state', which reflects the closest date to each transition. -->
<!-- ``` -->
<!-- Lastly, we save this animation to file using the `anim_save` function. -->
<!-- ```{r, eval=FALSE} -->
<!-- anim_save('output/ndvi_animation.gif') # lastly, we save this as a gif. -->
<!-- ``` -->
<!-- #### Export summarised NDVI raster -->
<!-- For your next practical, you will be collecting different environmental variables to describe the habitat conditions most important to *Protea roupelliae* using species distribution models. NDVI is frequently used in these models. Let's export a summarised NDVI layer for later use. First convert our list of rasters into a single raster with several layers (or a raster collection). Then calculate the mean value for each pixel across each layer. -->
<!-- ```{r} -->
<!-- # Find mean value across each raster -->
<!-- spat_rast_coll <- rast(my_rast_crop) # convert the list to a single raster with many layers -->
<!-- mean_ndvi <- mean(spat_rast_coll, na.rm = TRUE) # calculate the mean across each layer -->
<!-- plot(mean_ndvi) -->
<!-- ``` -->
<!-- Our final step is to save this summary raster to file: -->
<!-- ```{r, eval=FALSE} -->
<!-- writeRaster(mean_ndvi, 'output/mean_ndvi.tiff') # save the raster to your output folder -->
<!-- ``` -->
</div>
<div id="extra-resources-for-using-ndvi-in-r" class="section level4">
<h4>Extra resources for using NDVI in R</h4>
<p>The <a
href="https://rspatial.org/terra/modis/index.html"><code>terra</code>
chapter</a> in the <a href="https://rspatial.org/">rspatial book</a> has
lots of excellent tutorials on the theory and application of the
<code>terra</code> package in R.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
