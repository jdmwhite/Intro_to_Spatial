<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>NDVI time series</title>

<script src="site_libs/header-attrs-2.14/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/paper.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/clipboard-1.7.1/clipboard.min.js"></script>
<link href="site_libs/primer-tooltips-1.4.0/build.css" rel="stylesheet" />
<link href="site_libs/klippy-0.0.0.9500/css/klippy.min.css" rel="stylesheet" />
<script src="site_libs/klippy-0.0.0.9500/js/klippy.min.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="Making_a_map.html">Making a map</a>
</li>
<li>
  <a href="Land_cover_change.html">Land cover change</a>
</li>
<li>
  <a href="NDVI_time_series.html">NDVI time series</a>
</li>
<li>
  <a href="SDMs.html">SDMs</a>
</li>
<li>
  <a href="Extras.html">Extras</a>
</li>
<li>
  <a href="Resources.html">Additional Resources</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">NDVI time series</h1>

</div>


<script>
  addClassKlippyTo("pre.r, pre.markdown");
  addKlippy('right', 'top', 'auto', '1', 'Copy code', 'Copied!');
</script>
<div id="learning-objectives" class="section level3">
<h3>Learning objectives</h3>
<ol style="list-style-type: decimal">
<li>Download MODIS vegetation indices</li>
<li>Process raster data</li>
<li>Produce a summarised time series</li>
</ol>
</div>
<div id="introduction" class="section level3">
<h3>Introduction</h3>
<p>In this tutorial, we will delve into satellite data to better
understand patterns of landscape change over space and time. So far, we
have explored spatial functions, but dealing with time and dates adds
another level of complexity to our analysis. To manage this, we will use
several <code>mapping</code> or <code>looping</code> functions. These
functions iterate a function over every element in our list or
collection. This is important to learn for many elements of programming
(such as in <a href="https://earthengine.google.com/">Google Earth
Engine</a>), but becomes extremely useful in collections of satellite
data over time.</p>
<div class="figure" style="text-align: center">
<img src="images/raster_by_time_edzer_UseR2019.png" alt="A collection of rasters over time. Source: Edzer Pebesma UseR! 2019 Spatial workshop" width="60%" />
<p class="caption">
A collection of rasters over time. Source: Edzer Pebesma UseR! 2019
Spatial workshop
</p>
</div>
<p>Satellite data can take many forms, but today we will be using
passive, optical data collected from the <a
href="https://viirsland.gsfc.nasa.gov/Val/VI_Val.html">NASA VIIRS
satellite</a>. This satellite works by capturing electromagnetic
information reflected from the surface of the earth using sensors.
Depending on the sensitivity of the satellite (i.e. the spectral
resolution), this information may be captured along different spectral
<strong>bands</strong>. Some of these we are familiar with, such as the
Red, Green or Blue band. When combining these bands together, they form
a ‘true’ colour image. They also collect spectral information along
longer wavelengths, in the infrared range. A band of particular
importance to understanding vegetation dynamics is the near-infrared
band.</p>
<div class="figure" style="text-align: center">
<img src="images/em_spectrum.png" alt="The electromagnetic spectrum, highlighting typical bands used in satellite remote sensing." width="60%" />
<p class="caption">
The electromagnetic spectrum, highlighting typical bands used in
satellite remote sensing.
</p>
</div>
</div>
<div id="ndvi" class="section level3">
<h3>NDVI</h3>
<p>There are certain properties of plants that make these bands useful
to us. For example, healthy vegetation reflects more near-infrared (NIR)
and green light, but absorbs more red and blue light. This is largely
why healthy vegetation looks green to our eyes. Vegetation that is
stressed or unhealthy will typically absorb more NIR and reflect more
red light, in turn producing different colours, which our eyes may
interpret as yellow or brown.</p>
<div class="figure" style="text-align: center">
<img src="images/ndvi_example.jpg" alt="The relationship between NIR and red bands for healthy (left) and unhealthy (right) vegetation. Source: NASA" width="60%" />
<p class="caption">
The relationship between NIR and red bands for healthy (left) and
unhealthy (right) vegetation. Source: NASA
</p>
</div>
<p>The Normalized Difference Vegetation Index uses the NIR and red bands
to formulate this relationship: <span class="math display">\[
NDVI = \frac{(NIR - red)}{(NIR + red)}
\]</span> NDVI can provide valuable information on phenology, vegetation
productivity, agriculture, or disturbancs such as deforestation, illegal
ploughing or wild fires.</p>
<p>From <strong>gisgeography</strong>: “Normalized Difference Vegetation
Index (NDVI) quantifies vegetation by measuring the difference between
near-infrared (which vegetation strongly reflects) and red light (which
vegetation absorbs).”</p>
<p>NDVI can only fall between -1 and 1. A simplified understanding of
NDVI values may say: values greater than 0.6 may indicate healthy
vegetation, values lower than 0.6 but greater than 0, may indicate
unhealthy vegetation. Values below 0 are likely to be water. Read up
more on NDVI at <a
href="https://gisgeography.com/ndvi-normalized-difference-vegetation-index/"><strong>gisgeography</strong></a>,
where they explain the calculation and the use of different satellite
bands.</p>
<div class="figure" style="text-align: center">
<img src="images/sa_modis.gif" alt="NDVI change over South Africa across a single year" width="60%" />
<p class="caption">
NDVI change over South Africa across a single year
</p>
</div>
<p>There are many other indices out there for vegetation, water, fire
scars and many more. For most satellites, we will need to calculate
these indices ourselves. Fortunately, there are also products, such as
the MODIS vegetation images, which provide these indices for us. We will
use these in our practical.</p>
</div>
<div id="tutorial" class="section level3">
<h3>Tutorial</h3>
<p>Let’s start coding. First install and load packages:</p>
<pre class="r"><code># install.packages(&#39;MODISTools&#39;)
# install.packages(&#39;tidyverse&#39;)
# install.packages(&#39;terra&#39;)
# install.packages(&#39;lubridate&#39;)

#### Load packages ----
library(MODISTools) # downloading modis data
library(tidyverse) # data manipulation and plotting
library(terra) # raster manipulation
library(lubridate) # dates</code></pre>
<div id="explore-the-data" class="section level4">
<h4>Explore the data</h4>
<p>Using the <code>MODISTools</code> package, we have direct access to
all of the Moderate Resolution Imaging Spectroradiometer (MODIS) and
other (e.g. VIIRS) satellite imagery. This satellite collects data on
the atmosphere, land and ocean. Read up more on the land mission <a
href="https://modis-land.gsfc.nasa.gov/">here</a>.</p>
<p>We will first load in our area of interest, which is the municipal
boundary for the City of Johannesburg.</p>
<pre class="r"><code>#### Load in our area of interest for later----
coj &lt;- vect(&quot;data/land_cover_change/COJ_boundary.shp&quot;)</code></pre>
<p>Then we will identify all of the products available through
<code>MODISTools</code>. We will then select the VIIRS product for
vegetation indices and explore the available bands. This product gives
both Normalized Difference Vegetation Index (NDVI) and Enhanced
Vegetation Index (EVI) every 16 days across the globe at a spatial scale
of 500m. Additionally, it provides RGB bands and information on the
pixel reliability, which we will both use.</p>
<p>There are products that produce a finer temporal and spatial
resolution, which may suit a study working within a smaller area, but we
will not require this here.</p>
<pre class="r"><code>#### Explore modis products ----
# All products available
products &lt;- mt_products()
head(products)</code></pre>
<pre><code>##        product
## 1       Daymet
## 2 ECO4ESIPTJPL
## 3      ECO4WUE
## 4       GEDI03
## 5     GEDI04_B
## 6      MCD12Q1
##                                                                       description
## 1 Daily Surface Weather Data (Daymet) on a 1-km Grid for North America, Version 4
## 2            ECOSTRESS Evaporative Stress Index PT-JPL (ESI) Daily L4 Global 70 m
## 3                       ECOSTRESS Water Use Efficiency (WUE) Daily L4 Global 70 m
## 4             GEDI Gridded Land Surface Metrics (LSM) L3 1km EASE-Grid, Version 2
## 5    GEDI Gridded Aboveground Biomass Density (AGBD) L4B 1km EASE-Grid, Version 2
## 6           MODIS/Terra+Aqua Land Cover Type (LC) Yearly L3 Global 500 m SIN Grid
##   frequency resolution_meters
## 1     1 day              1000
## 2    Varies                70
## 3    Varies                70
## 4  One time              1000
## 5  One time              1000
## 6    1 year               500</code></pre>
<pre class="r"><code># bands of the vegetation indices product
bands &lt;- mt_bands(product = &quot;VNP13A1&quot;)
head(bands)</code></pre>
<pre><code>##                                      band
## 1          500_m_16_days_blue_reflectance
## 2 500_m_16_days_composite_day_of_the_year
## 3                       500_m_16_days_EVI
## 4                      500_m_16_days_EVI2
## 5         500_m_16_days_green_reflectance
## 6                      500_m_16_days_NDVI
##                              description                  units     valid_range
## 1  Blue band (M3 478-498 nm) reflectance            reflectance      0 to 10000
## 2                        Day of the year Julian day of the year        1 to 366
## 3                     16 day EVI average   EVI ratio - No units -10000 to 10000
## 4                    16 day EVI2 average  EVI2 ratio - No units -10000 to 10000
## 5 Green band (M4 545-565 nm) reflectance            reflectance      0 to 10000
## 6                    16 day NDVI average  NDVI ratio - No units -10000 to 10000
##   fill_value scale_factor add_offset
## 1      -1000       0.0001          0
## 2         -1         &lt;NA&gt;       &lt;NA&gt;
## 3     -15000       0.0001          0
## 4     -15000       0.0001          0
## 5      -1000       0.0001          0
## 6     -15000       0.0001          0</code></pre>
<p>We can then explore all of the available dates for a location of
interest - in this case a central point in Johannesburg.</p>
<pre class="r"><code># dates available for a specific coordinate
dates &lt;- mt_dates(product = &quot;VNP13A1&quot;, lat = -26.2041, lon = 28.0473)
head(dates)</code></pre>
<pre><code>##   modis_date calendar_date
## 1   A2012017    2012-01-17
## 2   A2012025    2012-01-25
## 3   A2012033    2012-02-02
## 4   A2012041    2012-02-10
## 5   A2012049    2012-02-18
## 6   A2012057    2012-02-26</code></pre>
</div>
<div id="downloading-modis-data" class="section level4">
<h4>Downloading MODIS data</h4>
<p>We will now set up the parameters for downloading the vegetation
index (VI) data. This requires the product of interest (VIIRS Vegetation
Index product), latitude and longitude (Johannesburg) and a start and
end date (all of 2021). We can also specify which bands we want, which
will make our download faster. Here we take the NDVI band and a pixel
reliability band.</p>
<p>We can also specify an area around the coordinate to download data
from. Here we specify 25km left and right (<code>km_lr</code>) and 40km
above and below (<code>km_ab</code>).</p>
<pre class="r"><code>#### Download NDVI data for JHB ----
start_time &lt;- Sys.time()
jhb_ndvi &lt;- mt_subset(product = &quot;VNP13A1&quot;,
                          lat = -26.183483,
                          lon =  27.975311,
                          band = c(&quot;500_m_16_days_NDVI&quot;,
                                   &quot;500_m_16_days_pixel_reliability&quot;),
                          start = &quot;2021-01-01&quot;,
                          end = &quot;2021-12-30&quot;,
                          km_lr = 25,
                          km_ab = 40,
                          site_name = &quot;JHB&quot;,
                          internal = TRUE,
                          progress = TRUE)</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |==============                                                        |  20%
  |                                                                            
  |============================                                          |  40%
  |                                                                            
  |==========================================                            |  60%
  |                                                                            
  |========================================================              |  80%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |==============                                                        |  20%
  |                                                                            
  |============================                                          |  40%
  |                                                                            
  |==========================================                            |  60%
  |                                                                            
  |========================================================              |  80%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre class="r"><code>end_time &lt;- Sys.time()
# How long does it take to download 200 km2 of VIIRS NDVI data at 500 m resolution for 2 bands?
end_time - start_time</code></pre>
<pre><code>## Time difference of 1.342296 mins</code></pre>
<p>Impressively, this only took 1.5 minutes to download 46 images overe
200 km2. An interesting feature of the <code>MODISTools</code> package,
is that it downloads data as a <code>data.frame</code>. This makes it
easy to manipulate and immediately visualise using data wrangling tools
in the <code>tidyverse</code>. It is still a big data frame (~1.5
million rows) - so let’s filter and summarise it down a bit.</p>
</div>
<div id="plot-time-series" class="section level4">
<h4>Plot time series</h4>
<p>Our aim is to produce a single median NDVI value for each unique date
and plot it. Importantly, we need to rescale the NDVI data using the
value in the <code>scale</code> column.</p>
<pre class="r"><code># Summarise
jhb_ndvi %&gt;% 
  filter(band == &quot;500_m_16_days_NDVI&quot;) %&gt;%
  group_by(calendar_date) %&gt;%
  summarise(doy = yday(as_date(calendar_date)),
            ndvi_median = median(value * as.numeric(scale))) %&gt;% 
  distinct(doy, .keep_all = TRUE) -&gt; jhb_med_ndvi
head(jhb_med_ndvi)</code></pre>
<pre><code>## # A tibble: 6 × 3
## # Groups:   calendar_date [6]
##   calendar_date   doy ndvi_median
##   &lt;chr&gt;         &lt;dbl&gt;       &lt;dbl&gt;
## 1 2021-01-01        1       0.620
## 2 2021-01-09        9       0.563
## 3 2021-01-17       17       0.562
## 4 2021-01-25       25       0.329
## 5 2021-02-02       33       0.634
## 6 2021-02-10       41       0.550</code></pre>
<pre class="r"><code># Plot
ggplot(jhb_med_ndvi, aes(x = doy, y = ndvi_median)) +
  geom_point() +
  geom_smooth(method = &#39;loess&#39;) +
  labs(x = &#39;Day of Year&#39;, y = &#39;NDVI (median)&#39;) +
  theme_classic() </code></pre>
<p><img src="NDVI_time_series_files/figure-html/summarise%20data-1.png" width="960" /></p>
<p>In very few lines of code - we already have a time series plot!</p>
<p>This clearly shows the seasonal pattern of the (southern hemisphere)
summer rainfall pattern of Johannesburg. The NDVI peaks in
December/January and is lowest in July/August just before the rains
begin. You may notice that in February there is a very odd, outlying
observation. Let’s convert the data frame to rasters to explore this a
bit further.</p>
<p>Before we move on let’s save the plot to file:</p>
<pre class="r"><code># Save plot
ggsave(&#39;output/figs/ndvi_time_series/jhb_med_ndvi.png&#39;,
       width = 120, height = 80, units = c(&#39;mm&#39;), dpi = &#39;retina&#39;, bg = &#39;white&#39;)</code></pre>
</div>
<div id="convert-ndvi-data-frame-to-rasters" class="section level4">
<h4>Convert NDVI data frame to rasters</h4>
<p>To convert the data frame to rasters, we will first split up the
large data frame into many smaller ones and store them in a list.</p>
<p>To do this, we first filter to only include our NDVI band and then
use the <code>split()</code> function by each <code>date</code>. The
output of this is a large list with 46 seperate data frames - one for
each date.</p>
<pre class="r"><code># filter to NDVI and then split the data frame into a list by date
jhb_ndvi_split &lt;- jhb_ndvi %&gt;% filter(band == &quot;500_m_16_days_NDVI&quot;) %&gt;% split(jhb_ndvi$calendar_date)</code></pre>
<pre><code>## Warning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data
## length is not a multiple of split variable</code></pre>
<p>We can now convert each data frame to a raster using the built in
<code>MODISTools</code> function <code>mt_to_raster()</code>. We nest
this function inside a call to <code>terra::rast()</code>, which
converts the <code>mt_to_raster()</code> output into a
<code>terra</code> style <code>SpatRast</code>, which is easier to
manipulate.</p>
<p>We put this all inside the <code>lapply()</code> function, which will
<code>loop</code> this function over each element of our list. The
output is another list, but this time full of rasters.</p>
<pre class="r"><code># convert each date into a raster (and reproject)
jhb_ndvi_rast_list &lt;- lapply(jhb_ndvi_split, function(x) {terra::rast(mt_to_raster(x, reproject = TRUE))})</code></pre>
<p>Using the <code>terra::rast()</code> function again, we can now
convert this list of rasters into a <strong>raster stack</strong>. This
<strong>stack</strong> can then be easily manipulated, like masking the
pixels to only be inside our area of interest - Johannesburg.</p>
<pre class="r"><code># convert the list of rasters into a raster stack
jhb_ndvi_rasts &lt;- rast(jhb_ndvi_rast_list)
jhb_ndvi_rasts &lt;- mask(jhb_ndvi_rasts, coj)</code></pre>
<p>Let’s now visualise our odd outlying date. We will plot both the
first image and the image on the 25th of January using the
<code>terra::plot()</code> function, which is an easy way to quickly
view our data.</p>
<pre class="r"><code># plot out two dates
plot(jhb_ndvi_rasts$`2021-01-01`, main = &#39;2021-01-01&#39;)
plot(coj, add = T)</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<pre class="r"><code>plot(jhb_ndvi_rasts$`2021-01-25`, main = &#39;2021-01-25&#39;)
plot(coj, add = T)</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-5-2.png" width="672" /></p>
<p>We can clearly see that there is something odd in our second image.
Large portions have very low NDVI values. Can you think of why this may
be the case?</p>
<p>Let’s explore this further using the pixel reliability index.</p>
</div>
<div id="convert-pixel-reliability-to-raster" class="section level4">
<h4>Convert Pixel Reliability to raster</h4>
<p>We will repeat the same steps as we did above for the NDVI band, but
this time filter the data to only the pixel reliability band. We will
end by plotting out 3 dates: our first image, 25th of January and then
an image from June (in the dry winter months).</p>
<pre class="r"><code># filter to pixel reliability band and then split the data frame into a list by date
jhb_pr_split &lt;- jhb_ndvi %&gt;% filter(band == &quot;500_m_16_days_pixel_reliability&quot;) %&gt;% split(jhb_ndvi$calendar_date)</code></pre>
<pre><code>## Warning in split.default(x = seq_len(nrow(x)), f = f, drop = drop, ...): data
## length is not a multiple of split variable</code></pre>
<pre class="r"><code># convert each date into a raster (and reproject)
jhb_pr_rast_list &lt;- lapply(jhb_pr_split, function(x) {rast(mt_to_raster(x, reproject = TRUE))})

# convert the list of rasters into a raster stack
jhb_pr_rasts &lt;- rast(jhb_pr_rast_list)
jhb_pr_rasts &lt;- mask(jhb_pr_rasts, coj)

# plot out a few dates
plot(jhb_pr_rasts$`2021-01-01`, main = &#39;2021-01-01&#39;)</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<pre class="r"><code>plot(jhb_pr_rasts$`2021-01-25`, main = &#39;2021-01-25&#39;)</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-6-2.png" width="672" /></p>
<pre class="r"><code># these are unreliable images
plot(jhb_pr_rasts$`2021-06-18`, main = &#39;2021-06-18&#39;) # this is a reliable image</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-6-3.png" width="672" /></p>
<pre class="r"><code># scores below 3 are acceptable</code></pre>
<p>We can immediately see that images 1 and 2 have very high scores
(above 3). Any value above 3 is likely to be an unreliable pixel. Our
last image most has values below 3.</p>
<p>An ideal workflow from here would be to filter NDVI pixel out with an
unreliable pixel score. We won’t do it here, but keep this in mind if
you are getting strange outliers.</p>
</div>
<div id="plot-rgb" class="section level4">
<h4>Plot RGB</h4>
<p>To better visualise this, we will now plot the true colour image
using the red, green and blue bands for a limited region (20 km each
direction of our point of interest) and for a single date (25th January
2021). We download and process our new data in the same way as
before:</p>
<pre class="r"><code># Using the same dataset, now download the red, green and blue bands to plot a true colour image for just the 25th January 2021
jhb_rgb &lt;- mt_subset(product = &quot;VNP13A1&quot;,
                     lat = -26.183483,
                     lon =  27.975311,
                     band = c(&quot;500_m_16_days_red_reflectance&quot;,
                               &quot;500_m_16_days_green_reflectance&quot;,
                               &#39;500_m_16_days_blue_reflectance&#39;),
                      start = &quot;2021-01-25&quot;,
                      end = &quot;2021-01-25&quot;,
                      km_lr = 20,
                      km_ab = 20,
                      site_name = &quot;JHB&quot;,
                      internal = TRUE,
                      progress = TRUE)</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre><code>## Downloading chunks:</code></pre>
<pre><code>## 
  |                                                                            
  |                                                                      |   0%
  |                                                                            
  |======================================================================| 100%</code></pre>
<pre class="r"><code># Split the data frame again, this time by band instead of calendar_date
jhb_rgb_split &lt;- split(jhb_rgb, jhb_rgb$band)

# convert to raster and reproject
jhb_rgb_rasts &lt;- lapply(jhb_rgb_split, function(x) {rast(mt_to_raster(x, reproject = TRUE))})

# combine the rasters together
jhb_rgb_rast &lt;- c(jhb_rgb_rasts[[1]], jhb_rgb_rasts[[2]], jhb_rgb_rasts[[3]])

# We can now use the plotRGB function to plot a true colour image
plotRGB(jhb_rgb_rast, stretch = &#39;hist&#39;)
plot(coj, add = TRUE)</code></pre>
<p><img src="NDVI_time_series_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>You may have guessed it by now and it is obvious to see that there is
a massive cloud in the middle of our image! Clouds are a serious issue
in optical remote sensing and can easily throw off NDVI measures. The
MODIS and VIIRS products try to account for this by averaging data over
a 16-day time period. But even then in areas with lots of cloud cover,
like Johannesburg in its rainy summer and frequently in the tropics,
this is a recurring issue. So keep this in mind when handling optical
satellite imagery and remember to filter these out if the issues are
severe using either pixel reliability measures or cloud-masking
methods.</p>
</div>
<div id="download-ndvi-for-multiple-sites" class="section level4">
<h4>Download NDVI for multiple sites</h4>
<p>We will now move onto download NDVI data for multiple sites. To do
this, we need to create or import a data frame with lat/lon coordinates
for each site. You can import this as a csv file. The function we will
use is <code>MODISTools::mt_batch_subset()</code>. This requires your
data frame to have a <code>lat</code>, <code>lon</code> and
<code>site_name</code> column. Rename your variables using
<code>names(df) &lt;- c('site_name', 'lat', 'lon')</code> if they have
different names. We will quickly create a data frame in R, using lat/lon
coordinates for 3 cities: Johannesburg, Accra and Nairobi.</p>
<p>We the use the <code>mt_batch_subset()</code> function and use a
buffer of only 2km each direction for each city and extract only the
NDVI values for 2021.</p>
<pre class="r"><code># Batch download
# Create a dataframe of sites and lat/lon or load in a csv
lat &lt;- c(-26.2041, 5.6037, -1.2921)
lon &lt;- c(28.0473, -0.1870, 36.8219)
site_name &lt;- c(&#39;JHB&#39;, &#39;ACC&#39;, &#39;NAI&#39;)
coords &lt;- data.frame(site_name, lat, lon)
coords</code></pre>
<pre><code>##   site_name      lat     lon
## 1       JHB -26.2041 28.0473
## 2       ACC   5.6037 -0.1870
## 3       NAI  -1.2921 36.8219</code></pre>
<pre class="r"><code># Use the mt_batch_subset function to load in data for multiple points
cities_ndvi &lt;- mt_batch_subset(df = coords,
                      product = &quot;VNP13A1&quot;,
                      band = c(&quot;500_m_16_days_NDVI&quot;),
                      start = &quot;2021-01-01&quot;,
                      end = &quot;2021-12-30&quot;,
                      km_lr = 2,
                      km_ab = 2,
                      internal = TRUE)</code></pre>
<p>For the amount of data we are downloading this works amazingly
quickly!</p>
<p>We can then summarise the data by city (site) and the date
(calendar_date) and pipe <code>%&gt;%</code> this directly into a
<code>ggplot()</code>. Note that we use
<code>facet_grid(cols = vars(site))</code> in the <code>ggplot()</code>
to create a separate plot for each city.</p>
<pre class="r"><code># Summarise the values by site and date and pipe this directly into a ggplot call
# Use facets to display a smoothed NDVI curve for each site
cities_ndvi %&gt;%
  group_by(site, calendar_date) %&gt;%
  summarise(doy = yday(as_date(calendar_date)),
            ndvi_median = median(value * as.numeric(scale))) %&gt;%
  distinct(doy, .keep_all = TRUE) %&gt;%
  ggplot(aes(x = doy, y = ndvi_median)) +
    geom_point(size = 0.8, alpha = 0.8) +
    geom_smooth(method = &#39;loess&#39;, col = &#39;darkgreen&#39;) +
    labs(x = &#39;Day of Year&#39;, y = &#39;NDVI (median)&#39;) +
    theme_classic() +
    facet_grid(cols = vars(site))</code></pre>
<p><img src="NDVI_time_series_files/figure-html/plot%20batch-1.png" width="960" /></p>
<p>And remember to save the plot:</p>
<pre class="r"><code># Save plot
ggsave(&#39;output/figs/ndvi_time_series/cities_med_ndvi.png&#39;,
       width = 180, height = 80, units = c(&#39;mm&#39;), dpi = &#39;retina&#39;, bg = &#39;white&#39;)</code></pre>
<pre><code>## `geom_smooth()` using formula &#39;y ~ x&#39;</code></pre>
<p>That is essentially the end of the learning objectives for this
tutorial. However, it is great to use time series data in presentations
and to best illustrate this, it can be useful to animate our plots.
Scroll down to the bonus section to see how this can be done:</p>
</div>
<div id="animate-time-series" class="section level4">
<h4>Animate time series</h4>
<pre class="r"><code># Animate ----
# Bonus - animate your NDVI rasters
# requires additional packages
# install.packages(c(&#39;gganimate&#39;,&#39;magick&#39;))
library(gganimate)
library(magick)
library(sf)

# Just for speed we&#39;ll aggregate the raster data
ndvi_rast_agg &lt;- aggregate(jhb_ndvi_rasts, 5)
# Convert it to a data frame and pivot to a long df
rast_df &lt;- as.data.frame(ndvi_rast_agg, xy = T) %&gt;% pivot_longer(cols = 3:48, names_to = &#39;Date&#39;, values_to = &#39;NDVI&#39;)

#### Map animation
anim_map &lt;- ggplot(rast_df) +
  geom_tile(aes(x = x, y = y, fill = NDVI, col = NDVI)) +
  scale_fill_gradientn(colours = rev(terrain.colors(7)),limits = c(0,1), breaks = seq(0,1,0.25)) +
  scale_colour_gradientn(colours = rev(terrain.colors(7)),limits = c(0,1), breaks = seq(0,1,0.25)) +
  geom_sf(data = st_as_sf(coj), fill = NA) +
  theme_void() +
  labs(title = &quot;{frame_time}&quot;) +
  gganimate::transition_time(as_date(Date))

# Render the plot
anim_map_param &lt;- gganimate::animate(anim_map, fps = 10,
                                     width = 720, 
                                     height = 480,
                                     res = 150, 
                                     renderer = gifski_renderer(&quot;output/figs/ndvi_time_series/gifs/animation1.gif&quot;))

# Time series animation
anim_ts &lt;- ggplot(jhb_med_ndvi, aes(x = as_date(calendar_date), y = ndvi_median)) +
  geom_point(aes(group = seq_along(doy), col = ndvi_median)) +
  geom_line(aes(col = ndvi_median), lwd = 1) +
  scale_colour_gradientn(colours = rev(terrain.colors(7)),limits = c(0,1), breaks = seq(0,1,0.25)) +
  scale_x_date(breaks = scales::date_breaks(&#39;months&#39;),labels = scales::date_format(&#39;%b&#39;)) +
  scale_y_continuous(limits = c(0,1), breaks = seq(0,1,0.25)) +
  labs(x = &#39;Date&#39;, y = &#39;NDVI (median)&#39;,
       title = &#39;City of Johannesburg NDVI over 2021&#39;,
       subtitle = &#39;VIIRS/S-NPP Vegetation Indices 16-Day 500m&#39;) +
  theme_classic() +
  theme(legend.position = &#39;none&#39;) +
  gganimate::transition_reveal(doy)   

# Render the plot
anim_ts_param &lt;- gganimate::animate(anim_ts, fps = 10,
                   width = 720, height = 480,
                   res = 150,
                   renderer = gifski_renderer(&quot;output/figs/ndvi_time_series/gifs/animation2.gif&quot;))

# Read them back in using magick::imageread
map_mgif &lt;- image_read(path = anim_map_param)
ts_mgif &lt;- image_read(path = anim_ts_param)

# Combine the first frame of each gif
combined_gifs &lt;- image_append(c(map_mgif[1], ts_mgif[1]))
# Loop in each additional frame and combine
for(i in 2:100){
  combined &lt;- image_append(c(map_mgif[i], ts_mgif[i]))
  combined_gifs &lt;- c(combined_gifs, combined)
}
combined_gifs</code></pre>
<p><img
src="NDVI_time_series_files/figure-html/unnamed-chunk-9-1.gif" /><!-- --></p>
<pre class="r"><code># Save combined gifs
image_write_gif(
  image = combined_gifs,
  path = &quot;output/figs/ndvi_time_series/gifs/combined_gifs.gif&quot;
)</code></pre>
<pre><code>## [1] &quot;/Users/Joseph/Dropbox/2022_Research/SAEON_GSN_R/Intro_to_Spatial/Intro_to_Spatial/output/figs/ndvi_time_series/gifs/combined_gifs.gif&quot;</code></pre>
</div>
<div id="extra-resources-for-using-ndvi-in-r" class="section level4">
<h4>Extra resources for using NDVI in R</h4>
<p>The <a
href="https://rspatial.org/terra/modis/index.html"><code>terra</code>
chapter</a> in the <a href="https://rspatial.org/">rspatial book</a> has
lots of excellent tutorials on the theory and application of the
<code>terra</code> package in R. Find more information on
<code>MODISTools</code> <a
href="https://jepsonnomad.github.io/tutorials/MODISTools_Intro.html">here</a>
and <a
href="https://onlinelibrary.wiley.com/doi/10.1002/ece3.1273">here</a>.</p>
<p>For access to a much broader collection of remote sensing data you
may consider going through the <a
href="https://github.com/r-spatial/rgee"><code>rgee</code> package</a>,
which links together R and Google Earth Engine.</p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
